# Content Service properties
# Service properties
server.port=8081
server.max-http-header-size=65536
server.compression.mime-types=application/json,application/xml
server.compression.enabled=true
server.http2.enabled=true
# Install properties
# To expose JMX endpoints, add these properties, adjusting port and hostname as desired:
# -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=8108 -Dcom.sun.management.jmxremote.rmi.port=8108 -Djava.rmi.server.hostname=localhost
install.jvmargs=-XX:+AlwaysPreTouch -XX:+ScavengeBeforeFullGC -XX:+DisableExplicitGC -Dlogging.config=config/logback.xml --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent.atomic=ALL-UNNAMED --add-opens=java.base/java.nio=ALL-UNNAMED --add-opens=java.base/java.util.concurrent.atomic=ALL-UNNAMED --add-modules=java.se --add-exports=java.base/jdk.internal.ref=ALL-UNNAMED --add-exports=jdk.management/com.ibm.lang.management.internal=ALL-UNNAMED --add-opens=java.base/sun.nio.ch=ALL-UNNAMED --add-opens=java.management/sun.management=ALL-UNNAMED --add-opens=jdk.management/com.sun.management.internal=ALL-UNNAMED
install.minHeap=512m
install.maxHeap=750m
install.service=TridionContentService
install.displayName=Tridion Content Service
install.description=Provides content services for web applications
# Dependent Windows services. If there are no such services, leave this property commented out. Dependent services are
# separated using either # or ; characters.
# install.dependsOn=TridionDiscoveryService
install.timeout=90000
# Register the service automatically in discovery
install.auto-register=${auto-register:true}
# Sentinel EMS Customer ID
ems.customer.id=
# DTAP Environment
# The cdenvironment property must be set via an Environment Variable or System property. This is used to differentiate
# services from different DTAP environments sharing common infrastructure such as logging systems, or caches.
# Access log properties. It's more typical to use a load balancer in front of the service and capture logs there.
# Switch on/off access logging
#server.tomcat.accesslog.enabled=true
# Access log message pattern. Could be both formats: common and combined.
# Common format: %h %l %u %t "%r" %s %b %D
# Combined format: %h %l %u %t "%r" %s %b "%{Referer}i" "%{User-Agent}i"
#server.tomcat.accesslog.pattern=%h %l %u %t "%r" %s %b %D
# Access log directory
#server.tomcat.accesslog.directory=c:/UDP/log
# Access log file name prefix
#server.tomcat.accesslog.prefix=access_log
# Access log file name suffix
#server.tomcat.accesslog.suffix=.log
# SSL properties for securing the service directly. It's more common to use a load balancer in front of the service.
server.ssl.enabled=true
server.ssl.protocol=TLS
server.ssl.key-alias=1
#server.ssl.key-passwd=<key password - default: changeit>
server.ssl.key-store=C:\\tridion\\ContentDelivery\\microservice_certificate\\wildcard_tridiondemo_com.jks
server.ssl.key-store-password=TRIDIONDEMO
spring.graphql.websocket.path=/cd/subscription
spring.config.import=optional:classpath:META-INF/build-info.properties
# Active profiles
#   broker is the default profile to enable broker DB lookups
#   search is the profile to enable search capabilities
#   ish is the profile to enable ish scm
spring.profiles.active=${contentspringprofilesactive:broker,search,ish}
spring.application.name=${service:content-service}
logging.pattern.level=%5p [${spring.application.name:-},${customer:-},${environment:-},${cdenvironment:-}]
service.svc.prefix=/content.svc
endpoints.enabled=false
endpoints.mappings.enabled=true
allowedAutoRegistrationCapabilities=ContentServiceCapability
rules.location=content-rw-rules.xml
endpoints.health.enabled=true
# Cache configuration
spring.cache.type=jcache
spring.cache.jcache.provider=org.apache.ignite.cache.CachingProvider
spring.cache.jcache.config=${cacheconf:file:config/cache-conf.xml}
# Enable cache for entire service
cache.enabled=${cacheenabled:false}
cache.invalidation.check.timeout=${cacheinvalidationchecktimeout:0}
#Maximum size in bytes of binaries to be cached. High values can lead to memory issues. Defaults to 1MB.
cache.max.binary.size=${cachemaxbinarysize:1048576}
# Enable or disable cache for a specific cache name in a form:
#   cache.content.<cachename>.enabled
# where <cachename> can be one of the following:
#   BinaryComponent, BinaryContent, BinaryVariant, Component, ComponentPresentation,
#   ComponentPresentationContent, ContentJsonByPath, ContentParsedJson, ContentRawJson, CustomMeta,
#   Page, Publication, Schema, Taxonomy, TaxonomyKeywords, TaxonomyList, Template, EvictionBlocks.
#
# An example of this would be disabling the PAGE cache:
#   cache.content.page.enabled=false
#
# Notes:
#  * Expiration policies or any other extended cache properties you can configure in cache-conf.xml.
#  * The EvictionBlocks cache is used by the deployer to trigger flushes to various other caches. So if you have
#    at least one cache enabled - this cache should be enabled too.
# Content API properties
content.api.endpoint=/cd/api
content.api.tracing.enabled=${tracingenabled:false}
graphql.introspection.enabled=${introspectionenabled:true}
graphql.mutations.enabled=${mutationsenabled:false}
content.api.search.default.result.size=${contentapisearchdefaultresultsize:100}
content.api.suggest.default.result.size=${contentapisuggestdefaultresultsize:10}
# Perform rule validation on graphql queries, by default this is true but if you are not interested in error reporting
# of malformed graphql queries you may benefit from slight performance improvement by setting this to false
content.api.validation.enabled=${validationenabled:true}
content.api.date.precision.enabled=${dateprecisionenabled:true}
# Enable request caching
graphql.request.caching.enabled=${graphqlrequestcachingenabled:false}
# Time between successive requests for request caching to occur in milliseconds
graphql.request.caching.buffer.time=${graphqlrequestcachingbuffertime:20000}
# Max capacity of cache
graphql.request.caching.capacity=${graphqlrequestcachingcapacity:50}
# TTL in seconds
graphql.request.caching.ttl=${graphqlrequestcachingttl:60}
# Cache cleanup interval in seconds
graphql.request.caching.cleanup.interval=${graphqlrequestcachingcleanupinterval:60}
# GraphQL Semantic Content Modelling (SCM)
# Is turned on by default
graphql.scm.enabled=${graphqlscmenabled:true}
# Disable legacy SCM (from external graphql schema definition files)
graphql.legacy.scm.enabled=${graphqllegacyscmenabled:false}
# Read all existing schemas on service startup from DB
graphql.scm.load.schemas.on.startup=${graphqlscmloadschemasonstartup:true}
# GraphQL schema update using polling
# Is turned off by default with a default time interval of 15 minutes (measured in milliseconds)
graphql.scm.update.polling.enabled=${graphqlscmupdatepollingenabled:false}
graphql.scm.update.interval=${graphqlscmupdateinterval:900000}
# GraphQL user defined schema directory
# For defining external source use graphql.file.dir="file:C:/content/schemas"
#graphql.file.dir=classpath*:/schemas
# Search API properties
# Required profiles to activate search: broker, search
os.host=${oshost:<os_host_name>}
os.port=${osport:<os_port>}
os.scheme=${osscheme:https}
os.username=
os.password=
index.common.name.prefix=${indexprefix:}
# Session enabled content service
session.preview.enabled=${sessionenabled:false}
server.servlet.session.timeout=1
server.servlet.session.cookie.secure=${securecookies:false}
# Add-on service configuration
addon.service.enabled=true
# Add-on client connection timeout (ms)
addon.client.timeout=${addonclienttimeout:500}
# Add-on heartbeat interval. Determines how often we should report live status of a service to add-on service.
# Default value is every 60000 millis = 1 minute.
addon.heartbeat.interval=60000
# Enable GQL addons query and addon endpoint which enables getting addons and configurations.
# Addon service should be enabled and URL provided to the content service.
content.api.addon.enabled=${contentapiaddonenabled:false}
# The following Add-on service properties can only be set via environment variables:
# addonserviceurl, openidconnecturl, openidconnectclientid, openidconnectclientsecret, openidconnectresource,
# openidconnectaudience, openidconnectprovidertype, openidconnectscope
# Storage transaction monitor
# if set to 'false' then StorageManagerTransactionMonitor will not run in background
storage.transaction.monitor.enabled=${storagetransactionmonitorenabled:false}
# Enable Spring security
service.security.enabled=${servicesecurityenabled:false}
# Cross Origin Requests (CORS) properties
# If this property is missing or set to false, then the remaining properties will be ignored
cors.constraints.enabled=${contentcorsconstraintsenabled:false}
cors.mappings=${contentcorsmappings:/**}
cors.methods=${contentcorsmethods:HEAD GET PUT PATCH DELETE POST}
cors.allowedOriginPatterns=${contentcorsorigins:https://<domain_name>:<port_no> }
cors.headers=${contentcorsheaders:*}
cors.exposedHeaders=${contentcorsexposedheaders:* Authorization}
cors.maxAge=${contentcorsmaxage:1800000}
# SSRF restriction properties
# If this property is missing or set to false, then the remaining configuration properties will be ignored
ssrf.constraints.enabled=${contentssrfconstraintsenabled:false}
ssrf.process.unknown.uri=${contentssrfunknownurienabled:THROW_EXCEPTION}
ssrf.allowed.patterns=${contentssrfallowedpatterns:https?://((?>\\d+\\.){3}\\d+|[-.0-9a-zA-Z]+)(:\\d+)?/ https?://((?>\\d+\\.){3}\\d+|[-.0-9a-zA-Z]+)(:\\d+)?/token.svc https?://localhost:808\\d/ }
ssrf.prohibited.patterns=${contentssrfprohibitedpatterns:}

#monitoring
management.otlp.metrics.export.enabled=${managementotlpmetricsexportenabled:false}
management.otlp.metrics.export.url=${managementotlpmetricsexporturl:}
management.otlp.metrics.export.step=${managementotlpmetricsexportstep:1m}
management.otlp.metrics.export.base-time-unit=seconds
management.otlp.metrics.export.aggregation-temporality=cumulative